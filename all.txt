=== ./src/api/compile.ts ===
import type { CompileResult } from '../types';

export type CompileResponse = CompileResult;

const API_BASE =
  (typeof import.meta !== 'undefined' && import.meta.env?.VITE_API_BASE) ||
  'http://localhost:3000';

export async function compileSchema(
  schemaSrc: string
): Promise<CompileResponse> {
  const ctrl = new AbortController();
  const timeout = setTimeout(() => ctrl.abort(), 15000); // 15s hard timeout

  try {
    const response = await fetch(`${API_BASE}/api/kumi/compile`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ schema_src: schemaSrc }),
      signal: ctrl.signal,
    });

    if (!response.ok) {
      const ctype = response.headers.get('content-type') || '';
      if (ctype.includes('application/json')) {
        const error = await response.json().catch(() => ({}));
        throw new Error(error.errors?.[0] || 'Compilation failed');
      } else {
        const text = await response.text().catch(() => '');
        throw new Error(text || `HTTP ${response.status}`);
      }
    }

    return response.json();
  } catch (err) {
    if ((err as any)?.name === 'AbortError') {
      throw new Error('Compilation request timed out');
    }
    throw err as Error;
  } finally {
    clearTimeout(timeout);
  }
}

export const compileKumiSchema = compileSchema;

=== ./src/App.tsx ===
// src/App.tsx
import { useState, useRef } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { SchemaTabContainer, type SchemaTabContainerRef } from '@/components/SchemaTabContainer';
import { CompiledCodeView } from '@/components/CompiledCodeView';
import { ExecuteTab, type ExecuteTabRef } from '@/components/ExecuteTab';
import { ExampleSelector } from '@/components/ExampleSelector';
import { KeyboardShortcutsHelp } from '@/components/KeyboardShortcutsHelp';
import { StickyActionBar } from '@/components/StickyActionBar';
import { Button } from '@/components/ui/button';
import { Keyboard } from 'lucide-react';
import { useKeyboard } from '@/hooks/useKeyboard';
import { VisualizeTab, type VisualizeTabRef } from '@/components/VisualizeTab';
import { useExampleState } from '@/hooks/useExampleState';
import type { CompileResponse } from '@/api/compile';
import { examples, getDefaultExample } from '@/examples';
import type { Example } from '@/types';

export function App() {
  const schemaTabContainerRef = useRef<SchemaTabContainerRef>(null);
  const executeTabRef = useRef<ExecuteTabRef>(null);
  const visualizeTabRef = useRef<VisualizeTabRef>(null);
  const [currentExample, setCurrentExample] = useState<Example>(getDefaultExample());

  const {
    schemaSource,
    setSchemaSource,
    compiledResult,
    setCompiledResult,
    executionConfig,
    setExecutionConfig,
    visualizationConfig,
    setVisualizationConfig,
  } = useExampleState(currentExample);

  const [compileError, setCompileError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState('schema');
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [isCompiling, setIsCompiling] = useState(false);
  const [isExecuting, setIsExecuting] = useState(false);

  const handleCompileSuccess = (result: CompileResponse) => {
    setCompiledResult(result);
    setCompileError(null);
    setActiveTab('compiled');
  };

  const handleCompileError = (error: string) => { setCompileError(error); setCompiledResult(null); };

  const handleExampleChange = (example: Example) => {
    setCurrentExample(example);
    setCompiledResult(null);
    setCompileError(null);
    setActiveTab('schema');
  };

  useKeyboard({
    'meta+1': () => { (document.activeElement as HTMLElement)?.blur(); setActiveTab('schema'); },
    'meta+2': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('compiled'); } },
    'meta+3': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('execute'); } },
    'meta+4': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('visualize'); } },
    'ctrl+1': () => { (document.activeElement as HTMLElement)?.blur(); setActiveTab('schema'); },
    'ctrl+2': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('compiled'); } },
    'ctrl+3': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('execute'); } },
    'ctrl+4': () => { if (compiledResult) { (document.activeElement as HTMLElement)?.blur(); setActiveTab('visualize'); } },
    'meta+enter': () => {
      const blur = () => (document.activeElement as HTMLElement)?.blur();
      const go = (tab: 'schema' | 'compiled' | 'execute' | 'visualize') =>
        requestAnimationFrame(() => setActiveTab(tab));

      if (activeTab === 'schema') {
        blur();
        schemaTabContainerRef.current?.compile();
      } else if (activeTab === 'compiled') {
        blur();
        go('visualize');     // was 'execute'
      } else if (activeTab === 'visualize') {
        visualizeTabRef.current?.togglePlay();
      } else {
        executeTabRef.current?.execute();
      }
    },
    'ctrl+enter': () => {
      const blur = () => (document.activeElement as HTMLElement)?.blur();
      const go = (tab: 'schema' | 'compiled' | 'execute' | 'visualize') =>
        requestAnimationFrame(() => setActiveTab(tab));

      if (activeTab === 'schema') {
        blur();
        schemaTabContainerRef.current?.compile();
      } else if (activeTab === 'compiled') {
        blur();
        go('visualize');     // was 'execute'
      } else if (activeTab === 'visualize') {
        visualizeTabRef.current?.togglePlay();
      } else {
        executeTabRef.current?.execute();
      }
    },
  }, [compiledResult, activeTab]);

  return (
    <div className="h-screen flex flex-col bg-background pb-bottom-bar overflow-hidden">
      <header className="h-[var(--header-h)] border-b shadow-sm bg-card flex-shrink-0">
        <div className="px-6 h-full flex items-center justify-between max-w-[1800px] mx-auto">
          <h1 className="text-2xl font-bold tracking-tight text-primary">Kumi Play</h1>
          <div className="flex items-center gap-4">
            <Button variant="ghost" size="sm" onClick={() => setShowShortcuts(true)} className="gap-2 focus-ring text-muted-foreground hover:text-foreground">
              <Keyboard className="h-4 w-4" />
              <span className="hidden sm:inline">Shortcuts</span>
              <kbd className="hidden md:inline-block px-1.5 py-0.5 text-xs font-mono bg-muted rounded">?</kbd>
            </Button>
            <ExampleSelector examples={examples} currentExample={currentExample} onExampleChange={handleExampleChange} />
          </div>
        </div>
      </header>

      <main className="h-under-chrome min-h-0 overflow-hidden">
        <div className="h-full min-h-0 flex flex-col max-w-[1800px] mx-auto w-full p-6">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="h-full min-h-0 flex flex-col">
            <div className="sticky top-0 z-20 bg-background">
              <TabsList className="grid w-full grid-cols-4 mb-6">
                <TabsTrigger value="schema" className="gap-3">Schema<kbd className="hidden sm:inline-block ml-auto px-1.5 py-0.5 text-xs font-mono bg-muted rounded">⌘1</kbd></TabsTrigger>
                <TabsTrigger value="compiled" disabled={!compiledResult} className="gap-3">Compiled Code<kbd className="hidden sm:inline-block ml-auto px-1.5 py-0.5 text-xs font-mono bg-muted rounded">⌘2</kbd></TabsTrigger>
                <TabsTrigger value="execute" disabled={!compiledResult} className="gap-3">Execute<kbd className="hidden sm:inline-block ml-auto px-1.5 py-0.5 text-xs font-mono bg-muted rounded">⌘3</kbd></TabsTrigger>
                <TabsTrigger value="visualize" disabled={!compiledResult} className="gap-3">Visualize<kbd className="hidden sm:inline-block ml-auto px-1.5 py-0.5 text-xs font-mono bg-muted rounded">⌘4</kbd></TabsTrigger>
              </TabsList>
            </div>

            <div className="flex-1 min-h-0 overflow-hidden">
              <TabsContent value="schema" className="m-0 h-full">
                <SchemaTabContainer
                  ref={schemaTabContainerRef}
                  schemaSource={schemaSource}
                  onSchemaSourceChange={setSchemaSource}
                  executionConfig={executionConfig}
                  visualizationConfig={visualizationConfig}
                  onExecutionConfigChange={setExecutionConfig}
                  onVisualizationConfigChange={setVisualizationConfig}
                  onCompileSuccess={handleCompileSuccess}
                  onCompileError={handleCompileError}
                  compileError={compileError}
                  onCompileStart={() => setIsCompiling(true)}
                  onCompileEnd={() => setIsCompiling(false)}
                />
              </TabsContent>

              <TabsContent value="compiled" className="m-0 h-full">
                {compiledResult && <CompiledCodeView result={compiledResult} />}
              </TabsContent>

              <TabsContent value="execute" className="m-0 h-full">
                {compiledResult && (
                  <ExecuteTab
                    ref={executeTabRef}
                    compiledResult={compiledResult}
                    example={currentExample}
                    executionConfig={executionConfig}
                    hideInput={
                      executionConfig?.type === 'continuous' &&
                      !!executionConfig.continuous?.feedback_mappings?.length
                    }
                    onExecuteStart={() => setIsExecuting(true)}
                    onExecuteEnd={() => setIsExecuting(false)}
                  />
                )}
              </TabsContent>

              <TabsContent value="visualize" className="m-0 h-full">
                {compiledResult && (
                  <VisualizeTab
                    ref={visualizeTabRef}
                    compiledResult={compiledResult}
                    example={currentExample}
                    visualizationConfig={visualizationConfig}
                    executionConfig={executionConfig}
                  />
                )}
              </TabsContent>
            </div>
          </Tabs>
        </div>
      </main>

      <KeyboardShortcutsHelp isOpen={showShortcuts} onClose={() => setShowShortcuts(false)} />

      {activeTab === 'schema' && (
        <StickyActionBar
          action="compile"
          onAction={() => schemaTabContainerRef.current?.compile()}
          disabled={isCompiling}
          isLoading={isCompiling}
        />
      )}

      {activeTab === 'compiled' && compiledResult && (
        <StickyActionBar
          action="visualize"
          onAction={() => setActiveTab('visualize')}
        />
      )}

      {activeTab === 'execute' && compiledResult && (
        <StickyActionBar
          action="execute"
          onAction={() => executeTabRef.current?.execute()}
          disabled={isExecuting}
          isLoading={isExecuting}
        />
      )}

      {activeTab === 'visualize' && compiledResult && (
        <StickyActionBar
          action={visualizeTabRef.current?.isPlaying ? 'pause' : 'play'}
          onAction={() => visualizeTabRef.current?.togglePlay()}
        />
      )}

      {!(activeTab === 'schema' || (activeTab === 'compiled' && compiledResult) || (activeTab === 'execute' && compiledResult) || (activeTab === 'visualize' && compiledResult)) && (
        <div className="fixed inset-x-0 bottom-0 h-[var(--bottom-bar-h)] border-t bg-background/80 backdrop-blur z-40" />
      )}
    </div>
  );
}

=== ./src/components/CompiledCodeView.tsx ===
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card } from '@/components/ui/card';
import { EditorView } from '@/components/EditorView';
import type { CompileResponse } from '@/api/compile';

interface CompiledCodeViewProps {
  result: CompileResponse;
}

export function CompiledCodeView({ result }: CompiledCodeViewProps) {
  return (
    <div>
      <Tabs defaultValue="js">
        <TabsList>
          <TabsTrigger value="js">JavaScript</TabsTrigger>
          <TabsTrigger value="ruby">Ruby</TabsTrigger>
          <TabsTrigger value="lir">LIR</TabsTrigger>
        </TabsList>

        <TabsContent value="js" className="mt-4">
          <Card className="overflow-hidden">
            <div className="h-[600px]">
              <EditorView
                height="100%"
                language="javascript"
                value={result.js_src}
                readOnly
              />
            </div>
          </Card>
        </TabsContent>

        <TabsContent value="ruby" className="mt-4">
          <Card className="overflow-hidden">
            <div className="h-[600px]">
              <EditorView
                height="100%"
                language="ruby"
                value={result.ruby_src}
                readOnly
              />
            </div>
          </Card>
        </TabsContent>

        <TabsContent value="lir" className="mt-4">
          <Card className="overflow-hidden">
            <div className="h-[600px]">
              <EditorView
                height="100%"
                language="plaintext"
                value={result.lir}
                readOnly
              />
            </div>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

=== ./src/components/ConfigEditor.tsx ===
import { useState, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { EditorView } from '@/components/EditorView';
import type { ExecutionConfig, VisualizationConfig } from '@/types';

interface ConfigEditorProps {
  executionConfig: ExecutionConfig;
  visualizationConfig: VisualizationConfig;
  onExecutionConfigChange: (config: ExecutionConfig) => void;
  onVisualizationConfigChange: (config: VisualizationConfig) => void;
}

interface CombinedConfig {
  execution_config: ExecutionConfig;
  visualization_config: VisualizationConfig;
}

export function ConfigEditor({
  executionConfig,
  visualizationConfig,
  onExecutionConfigChange,
  onVisualizationConfigChange,
}: ConfigEditorProps) {
  const [jsonValue, setJsonValue] = useState(() =>
    JSON.stringify(
      { execution_config: executionConfig, visualization_config: visualizationConfig },
      null,
      2
    )
  );
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setJsonValue(
      JSON.stringify(
        { execution_config: executionConfig, visualization_config: visualizationConfig },
        null,
        2
      )
    );
  }, [executionConfig, visualizationConfig]);

  const handleChange = (value: string | undefined) => {
    if (value === undefined) return;

    setJsonValue(value);

    try {
      const parsed: CombinedConfig = JSON.parse(value);

      if (parsed.execution_config && parsed.visualization_config) {
        setError(null);
        onExecutionConfigChange(parsed.execution_config);
        onVisualizationConfigChange(parsed.visualization_config);
      }
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Invalid JSON');
    }
  };

  return (
    <div className="flex flex-col h-full">
      <Card className="overflow-hidden shadow-lg border-2 flex-1 min-h-[300px]">
        <div className="h-full">
          <EditorView
            height="100%"
            language="json"
            value={jsonValue}
            onChange={handleChange}
          />
        </div>
      </Card>

      {error && (
        <Card className="mt-6 p-4 bg-destructive/10 border-destructive shadow-sm">
          <p className="text-sm text-destructive font-mono leading-relaxed">Invalid JSON: {error}</p>
        </Card>
      )}
    </div>
  );
}

=== ./src/components/EditorView.tsx ===
import Editor, { type Monaco, type OnMount } from '@monaco-editor/react';
import type { editor as MonacoEditor } from 'monaco-editor';

interface EditorViewProps {
  value: string;
  language: string;
  onChange?: (value: string | undefined) => void;
  onMount?: OnMount;
  readOnly?: boolean;
  height?: string;
  options?: MonacoEditor.IStandaloneEditorConstructionOptions;
}

export function EditorView({
  value,
  language,
  onChange,
  onMount,
  readOnly = false,
  height = '100%',
  options = {},
}: EditorViewProps) {
  const handleMount: OnMount = (editor, monaco) => {
    const keybindingsService = (editor as any)._standaloneKeybindingService;

    if (keybindingsService) {
      const bindings = [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter,
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Digit1,
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Digit2,
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Digit3,
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,
      ];

      bindings.forEach(keybinding => {
        keybindingsService.addDynamicKeybinding(`-${keybinding}`, keybinding, () => {});
      });
    }

    onMount?.(editor, monaco);
  };

  return (
    <Editor
      height={height}
      language={language}
      value={value}
      onChange={onChange}
      theme="vs-dark"
      onMount={handleMount}
      options={{
        minimap: { enabled: false },
        fontSize: 14,
        lineNumbers: 'on',
        scrollBeyondLastLine: false,
        automaticLayout: true,
        padding: { top: 16, bottom: 16 },
        readOnly,
        ...options,
      }}
    />
  );
}

=== ./src/components/ExampleSelector.tsx ===
import type { Example } from '@/types';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

interface ExampleSelectorProps {
  examples: Example[];
  currentExample: Example;
  onExampleChange: (example: Example) => void;
}

export function ExampleSelector({
  examples,
  currentExample,
  onExampleChange,
}: ExampleSelectorProps) {
  const handleValueChange = (value: string) => {
    const example = examples.find((ex) => ex.id === value);
    if (example) {
      onExampleChange(example);
    }
  };

  return (
    <Select value={currentExample.id} onValueChange={handleValueChange}>
      <SelectTrigger className="w-[280px] border-2 border-border bg-muted text-foreground hover:bg-accent hover:border-primary transition-all">
        <SelectValue placeholder="Select an example" />
      </SelectTrigger>
      <SelectContent>
        {examples.map((example) => (
          <SelectItem key={example.id} value={example.id}>
            {example.title}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}

=== ./src/components/ExecuteTab.tsx ===
// src/components/ExecuteTab.tsx
import { useState, useEffect, useImperativeHandle, forwardRef } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { JsonInputEditor } from '@/components/JsonInputEditor';
import { OutputView } from '@/components/OutputView';
import { runAllOutputsFromUrl } from '@/execution/artifact-runner';
import { applyFeedbackMappings } from '@/execution/feedback-loop';
import type { CompileResponse } from '@/api/compile';
import type { Example, ExecutionConfig } from '@/types';

interface ExecuteTabProps {
  compiledResult: CompileResponse;
  example?: Example;
  executionConfig?: ExecutionConfig;
  onExecuteStart?: () => void;
  onExecuteEnd?: () => void;
  hideInput?: boolean;
}

export interface ExecuteTabRef {
  execute: () => Promise<void>;
  isExecuting: boolean;
}

export const ExecuteTab = forwardRef<ExecuteTabRef, ExecuteTabProps>(function ExecuteTab(
  { compiledResult, example, executionConfig, onExecuteStart, onExecuteEnd, hideInput = false },
  ref
) {
  const [inputValues, setInputValues] = useState<Record<string, any>>({});
  const [executionResult, setExecutionResult] = useState<Record<string, any> | null>(null);
  const [executionError, setExecutionError] = useState<string | null>(null);
  const [isExecuting, setIsExecuting] = useState(false);
  const [jsonError, setJsonError] = useState<string | null>(null);

  useEffect(() => {
    if (example?.base_input) setInputValues(example.base_input);
    setExecutionResult(null);
    setExecutionError(null);
  }, [example]);

  const handleExecute = async () => {
    setIsExecuting(true);
    setExecutionError(null);
    onExecuteStart?.();
    try {
      const results = await runAllOutputsFromUrl(
        compiledResult.artifact_url!,
        inputValues,
        compiledResult.output_schema
      );
      setExecutionResult(results);

      if (executionConfig?.type === 'continuous' && executionConfig.continuous?.feedback_mappings?.length) {
        const next = applyFeedbackMappings(executionConfig, results, inputValues);
        setInputValues(next);
      }
    } catch (error) {
      setExecutionError(error instanceof Error ? error.message : 'Execution failed');
      setExecutionResult(null);
    } finally {
      setIsExecuting(false);
      onExecuteEnd?.();
    }
  };

  useImperativeHandle(ref, () => ({ execute: handleExecute, isExecuting }));

  const isContinuous = executionConfig?.type === 'continuous' && !!executionConfig.continuous?.feedback_mappings?.length;
  const headingLabel = hideInput
    ? (isContinuous ? 'Input → Output (continuous)' : 'Output (auto-piped)')
    : 'Output';

  const wrapperClass = 'h-[calc(100vh-4rem)] min-h-0 p-6';
  const gridClass = hideInput
    ? 'grid grid-cols-1 gap-8 h-full items-stretch min-h-0'
    : 'grid grid-cols-2 gap-8 h-full items-stretch min-h-0';

  return (
    <div className={wrapperClass}>
      <div className={gridClass}>
        {!hideInput && (
          <div className="flex flex-col h-full min-h-0">
            <h3 className="text-sm font-medium text-muted-foreground uppercase tracking-wide mb-3">
              Input
            </h3>
            <Card className="shadow-lg border-2 flex-1 flex flex-col min-h-0">
              <CardContent className="pt-6 space-y-4 flex-1 min-h-0 flex">
                <div className="flex-1 min-h-0">
                  <JsonInputEditor value={inputValues} onChange={setInputValues} onError={setJsonError} height="100%" />
                </div>
                {jsonError && (
                  <p className="text-destructive text-sm font-medium">Invalid JSON: {jsonError}</p>
                )}
              </CardContent>
            </Card>
          </div>
        )}

        <div className="flex flex-col h-full min-h-0">
          <h3 className="text-sm font-medium text-muted-foreground uppercase tracking-wide mb-1">
            {headingLabel}
          </h3>
          {hideInput && isContinuous && (
            <p className="text-xs text-muted-foreground mb-3">
              Outputs feed back into inputs each run.
            </p>
          )}

          {executionError ? (
            <Card className="bg-destructive/10 border-destructive shadow-sm flex-1 flex flex-col min-h-0">
              <CardContent className="pt-6 flex-1 min-h-0 overflow-hidden">
                <p className="font-mono text-sm text-destructive leading-relaxed">{executionError}</p>
              </CardContent>
            </Card>
          ) : executionResult ? (
            <Card className="shadow-lg border-2 flex-1 flex flex-col overflow-hidden min-h-0">
              <CardContent className="pt-6 flex-1 min-h-0 flex flex-col">
                <div className="flex-1 min-h-0">
                  <OutputView
                    results={executionResult}
                    outputSchema={compiledResult.output_schema}
                    example={example}
                  />
                </div>
              </CardContent>
            </Card>
          ) : (
            <Card className="shadow-lg border-2 border-dashed bg-muted/20 flex-1 flex flex-col min-h-0">
              <CardContent className="pt-6 flex-1 min-h-0 flex items-center justify-center">
                <div className="text-center text-muted-foreground space-y-2">
                  <div className="text-4xl">⚡</div>
                  <p className="text-sm font-medium">
                    Press Execute to see results
                  </p>
                  <p className="text-xs">
                    <kbd className="px-2 py-1 text-xs font-mono bg-muted rounded">⌘↵</kbd>
                  </p>
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </div>
  );
});

=== ./src/components/InputForm.tsx ===
import { useState } from 'react';
import type { InputField } from '@/types';

interface InputFormProps {
  schema: Record<string, InputField>;
  values: Record<string, any>;
  onChange: (values: Record<string, any>) => void;
}

export function InputForm({ schema, values, onChange }: InputFormProps) {
  const [textValues, setTextValues] = useState<Record<string, string>>({});

  const handleChange = (name: string, value: any) => {
    onChange({ ...values, [name]: value });
  };

  const renderField = (name: string, field: InputField) => {
    if ('type' in field) {
      switch (field.type) {
        case 'integer':
          return (
            <input
              id={name}
              type="number"
              step="1"
              value={values[name] ?? ''}
              onChange={(e) => handleChange(name, parseInt(e.target.value) || 0)}
              className="w-full px-3 py-2 border rounded-md bg-background"
            />
          );

        case 'float':
          return (
            <input
              id={name}
              type="number"
              step="any"
              value={values[name] ?? ''}
              onChange={(e) => handleChange(name, parseFloat(e.target.value) || 0)}
              className="w-full px-3 py-2 border rounded-md bg-background"
            />
          );

        case 'string':
          return (
            <input
              id={name}
              type="text"
              value={values[name] ?? ''}
              onChange={(e) => handleChange(name, e.target.value)}
              className="w-full px-3 py-2 border rounded-md bg-background"
            />
          );

        case 'boolean':
          return (
            <input
              id={name}
              type="checkbox"
              checked={values[name] ?? false}
              onChange={(e) => handleChange(name, e.target.checked)}
              className="w-4 h-4"
            />
          );

        case 'array':
        case 'object':
          const currentText = name in textValues
            ? textValues[name]
            : (values[name] !== undefined ? JSON.stringify(values[name], null, 2) : '');

          return (
            <textarea
              id={name}
              value={currentText}
              onChange={(e) => {
                const newText = e.target.value;
                setTextValues({ ...textValues, [name]: newText });

                try {
                  const parsed = JSON.parse(newText);
                  handleChange(name, parsed);
                  delete textValues[name];
                } catch {
                  // Keep text in local state until valid JSON
                }
              }}
              className="w-full px-3 py-2 border rounded-md bg-background font-mono text-sm"
              placeholder="JSON value"
              rows={6}
            />
          );

        default:
          return (
            <input
              id={name}
              type="text"
              value={JSON.stringify(values[name] ?? '')}
              onChange={(e) => {
                try {
                  handleChange(name, JSON.parse(e.target.value));
                } catch {
                  handleChange(name, e.target.value);
                }
              }}
              className="w-full px-3 py-2 border rounded-md bg-background font-mono text-sm"
              placeholder="JSON value"
            />
          );
      }
    }

    return (
      <textarea
        id={name}
        value={values[name] !== undefined ? JSON.stringify(values[name], null, 2) : ''}
        onChange={(e) => {
          try {
            handleChange(name, JSON.parse(e.target.value));
          } catch {
            handleChange(name, e.target.value);
          }
        }}
        className="w-full px-3 py-2 border rounded-md bg-background font-mono text-sm"
        placeholder="JSON value"
        rows={6}
      />
    );
  };

  return (
    <div className="space-y-4">
      {Object.entries(schema).map(([name, field]) => (
        <div key={name}>
          <label htmlFor={name} className="block text-sm font-medium mb-2">{name}</label>
          {renderField(name, field)}
        </div>
      ))}
    </div>
  );
}

=== ./src/components/JsonInputEditor.tsx ===
import { useState, useEffect } from 'react';
import { EditorView } from '@/components/EditorView';

interface JsonInputEditorProps {
  value: Record<string, any>;
  onChange: (value: Record<string, any>) => void;
  onError?: (error: string | null) => void;
  height?: string;
}

export function JsonInputEditor({
  value,
  onChange,
  onError,
  height = '100%',
}: JsonInputEditorProps) {
  const [editorValue, setEditorValue] = useState(() => JSON.stringify(value, null, 2));

  useEffect(() => {
    setEditorValue(JSON.stringify(value, null, 2));
  }, [value]);

  const handleChange = (newValue: string | undefined) => {
    if (!newValue) return;
    setEditorValue(newValue);
    try {
      const parsed = JSON.parse(newValue);
      onChange(parsed);
      onError?.(null);
    } catch (e) {
      onError?.(e instanceof Error ? e.message : 'Invalid JSON');
    }
  };

  return (
    <EditorView
      height={height}
      language="json"
      value={editorValue}
      onChange={handleChange}
      options={{
        tabSize: 2,
        formatOnPaste: true,
      }}
    />
  );
}

=== ./src/components/JsonOutputViewer.tsx ===
// components/JsonOutputViewer.tsx
import { EditorView } from '@/components/EditorView';

interface JsonOutputViewerProps {
  value: any;
  height?: string; // use "100%" to fill parent
}

function safeJsonStringify(value: any): string {
  if (value === undefined) return 'undefined';
  try {
    return JSON.stringify(value, null, 2);
  } catch (error) {
    const msg = error instanceof Error ? error.message : 'Unknown error';
    const payload =
      error instanceof TypeError && msg.includes('circular')
        ? {
          error: 'Circular reference detected',
          message: 'Cannot stringify object with circular references',
        }
        : { error: 'Serialization error', message: msg };
    return JSON.stringify(payload, null, 2);
  }
}

export function JsonOutputViewer({ value, height = '100%' }: JsonOutputViewerProps) {
  const jsonString = safeJsonStringify(value);

  return (
    <EditorView
      height={height}
      language="json"
      value={jsonString}
      readOnly
      options={{
        tabSize: 2,
        scrollbar: { vertical: 'hidden', horizontal: 'auto', alwaysConsumeMouseWheel: false },
      }}
    />
  );
}

=== ./src/components/KeyboardShortcutsHelp.tsx ===
import { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { X } from 'lucide-react';

interface Shortcut {
  keys: string[];
  description: string;
  category?: string;
}

interface KeyboardShortcutsHelpProps {
  isOpen: boolean;
  onClose: () => void;
}

const shortcuts: Shortcut[] = [
  { keys: ['⌘', 'Enter'], description: 'Compile (in Schema) / Execute (in Execute)', category: 'Primary Actions' },
  { keys: ['⌘', 'K'], description: 'Toggle this help', category: 'Help' },
  { keys: ['Esc'], description: 'Close this help', category: 'Help' },
];

export function KeyboardShortcutsHelp({ isOpen, onClose }: KeyboardShortcutsHelpProps) {
  const [isMac, setIsMac] = useState(true);

  useEffect(() => {
    setIsMac(navigator.platform.toLowerCase().includes('mac'));
  }, []);

  useEffect(() => {
    if (isOpen) {
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      window.addEventListener('keydown', handleEscape);
      return () => window.removeEventListener('keydown', handleEscape);
    }
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const groupedShortcuts = shortcuts.reduce((acc, shortcut) => {
    const category = shortcut.category || 'Other';
    if (!acc[category]) acc[category] = [];
    acc[category].push(shortcut);
    return acc;
  }, {} as Record<string, Shortcut[]>);

  const translateKey = (key: string) => {
    if (isMac) return key;
    return key.replace('⌘', 'Ctrl');
  };

  return (
    <div
      className="fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center p-4"
      onClick={onClose}
    >
      <Card
        className="w-full max-w-2xl shadow-2xl border-2 animate-in fade-in-0 zoom-in-95 duration-200 m-auto"
        onClick={(e) => e.stopPropagation()}
      >
        <CardHeader className="flex flex-row items-center justify-between pb-4">
          <CardTitle className="text-2xl">Keyboard Shortcuts</CardTitle>
          <button
            onClick={onClose}
            className="rounded-lg p-2 hover:bg-accent transition-colors focus-ring"
            aria-label="Close"
          >
            <X className="h-5 w-5" />
          </button>
        </CardHeader>
        <CardContent className="space-y-6">
          {Object.entries(groupedShortcuts).map(([category, items]) => (
            <div key={category}>
              <h3 className="text-sm font-semibold text-muted-foreground mb-3 uppercase tracking-wider">
                {category}
              </h3>
              <div className="space-y-2">
                {items.map((shortcut, idx) => (
                  <div
                    key={idx}
                    className="flex items-center justify-between py-2 px-3 rounded-lg hover:bg-accent/50 transition-colors"
                  >
                    <span className="text-sm text-foreground">{shortcut.description}</span>
                    <div className="flex items-center gap-1">
                      {shortcut.keys.map((key, keyIdx) => (
                        <kbd
                          key={keyIdx}
                          className="px-2 py-1 text-xs font-mono bg-muted border border-border rounded shadow-sm min-w-[2rem] text-center"
                        >
                          {translateKey(key)}
                        </kbd>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
          <div className="pt-4 border-t border-border">
            <p className="text-xs text-muted-foreground text-center">
              Press <kbd className="px-1.5 py-0.5 text-xs font-mono bg-muted rounded">Esc</kbd> or click outside to close
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

=== ./src/components/OutputView.tsx ===
import type { OutputField, Example, VisualizationType, VisualizationConfig } from '@/types';
import { JsonOutputViewer } from './JsonOutputViewer';
import { TableVisualizer } from './visualizers/TableVisualizer';
import { GridVisualizer } from './visualizers/GridVisualizer';

interface OutputViewProps {
  results: Record<string, any>;
  outputSchema: Record<string, OutputField>;
  example?: Example;
  visualizationConfig?: VisualizationConfig;
}

const visualizers = {
  json: JsonOutputViewer,
  table: TableVisualizer,
  grid: GridVisualizer,
} as const;

export function OutputView({ results, example, visualizationConfig }: OutputViewProps) {
  const getVisualizationType = (outputName: string): VisualizationType => {
    const fromConfig = visualizationConfig?.outputs?.[outputName]?.type as VisualizationType | undefined;
    if (fromConfig && fromConfig in visualizers) return fromConfig;

    const fromExample = example?.visualizations?.[outputName] as VisualizationType | undefined;
    if (fromExample && fromExample in visualizers) return fromExample;

    if (fromConfig || fromExample) {
      console.warn(`Unknown visualization type for output "${outputName}", falling back to JSON`);
    }
    return 'json';
  };

  const jsonOutputs: Record<string, any> = {};
  const customVisualizations: Array<{ name: string; value: any; vizType: VisualizationType }> = [];

  Object.entries(results).forEach(([name, value]) => {
    const vizType = getVisualizationType(name);
    if (vizType === 'json') {
      jsonOutputs[name] = value;
    } else {
      customVisualizations.push({ name, value, vizType });
    }
  });

  return (
    <div className="flex flex-col h-full min-h-0 space-y-6">
      {Object.keys(jsonOutputs).length > 0 && (
        <div className="flex-1 min-h-0">
          <JsonOutputViewer value={jsonOutputs} height="100%" />
        </div>
      )}
      {customVisualizations.map(({ name, value, vizType }) => {
        const Visualizer = visualizers[vizType];
        return <Visualizer key={name} name={name} value={value} />;
      })}
    </div>
  );
}

=== ./src/components/SchemaEditor.tsx ===

import { useImperativeHandle, forwardRef, useRef } from 'react';
import { type Monaco } from '@monaco-editor/react';
import { Card } from '@/components/ui/card';
import { EditorView } from '@/components/EditorView';
import { compileSchema, type CompileResponse } from '@/api/compile';
import type { editor as MonacoEditor } from 'monaco-editor';


interface SchemaEditorProps {
  value: string;
  onChange: (value: string) => void;
  onCompileSuccess: (result: CompileResponse) => void;
  onCompileError: (error: string) => void;
  compileError: string | null;
  onCompileStart?: () => void;
  onCompileEnd?: () => void;
}

export interface SchemaEditorRef {
  compile: () => Promise<void>;
}

export const SchemaEditor = forwardRef<SchemaEditorRef, SchemaEditorProps>(({
  value,
  onChange,
  onCompileSuccess,
  onCompileError,
  compileError,
  onCompileStart,
  onCompileEnd,
}, ref) => {
  const editorRef = useRef<MonacoEditor.IStandaloneCodeEditor | null>(null);
  const monacoRef = useRef<Monaco | null>(null);

  const handleEditorChange = (newValue: string | undefined) => {
    if (newValue !== undefined) {
      onChange(newValue);
    }
  };

  const handleCompile = async () => {
    onCompileStart?.();
    try {
      const result = await compileSchema(value);
      onCompileSuccess(result);
    } catch (error) {
      onCompileError(error instanceof Error ? error.message : 'Compilation failed');
    } finally {
      onCompileEnd?.();
    }
  };

  const handleEditorDidMount = (editor: MonacoEditor.IStandaloneCodeEditor, monaco: Monaco) => {
    editorRef.current = editor;
    monacoRef.current = monaco;
  };

  useImperativeHandle(ref, () => ({
    compile: handleCompile,
  }));

  return (
    <div className="flex flex-col h-full">
      <Card className="overflow-hidden shadow-lg border-2 flex-1 min-h-[300px]">
        <div className="h-full">
          <EditorView
            height="100%"
            language="ruby"
            value={value}
            onChange={handleEditorChange}
            onMount={handleEditorDidMount}
          />
        </div>
      </Card>

      {compileError && (
        <Card className="mt-6 p-4 bg-destructive/10 border-destructive shadow-sm">
          <p className="text-sm text-destructive font-mono leading-relaxed">{compileError}</p>
        </Card>
      )}
    </div>
  );
});

=== ./src/components/SchemaTabContainer.tsx ===
import { useState, forwardRef, useImperativeHandle, useRef } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { SchemaEditor, type SchemaEditorRef } from '@/components/SchemaEditor';
import { ConfigEditor } from '@/components/ConfigEditor';
import type { CompileResponse } from '@/api/compile';
import type { ExecutionConfig, VisualizationConfig } from '@/types';

interface SchemaTabContainerProps {
  schemaSource: string;
  onSchemaSourceChange: (source: string) => void;
  executionConfig: ExecutionConfig;
  visualizationConfig: VisualizationConfig;
  onExecutionConfigChange: (config: ExecutionConfig) => void;
  onVisualizationConfigChange: (config: VisualizationConfig) => void;
  onCompileSuccess: (result: CompileResponse) => void;
  onCompileError: (error: string) => void;
  compileError: string | null;
  onCompileStart?: () => void;
  onCompileEnd?: () => void;
}

export interface SchemaTabContainerRef {
  compile: () => Promise<void>;
}

export const SchemaTabContainer = forwardRef<SchemaTabContainerRef, SchemaTabContainerProps>(
  (
    {
      schemaSource,
      onSchemaSourceChange,
      executionConfig,
      visualizationConfig,
      onExecutionConfigChange,
      onVisualizationConfigChange,
      onCompileSuccess,
      onCompileError,
      compileError,
      onCompileStart,
      onCompileEnd,
    },
    ref
  ) => {
    const [schemaSubTab, setSchemaSubTab] = useState('schema');
    const schemaEditorRef = useRef<SchemaEditorRef>(null);

    useImperativeHandle(ref, () => ({
      compile: async () => {
        await schemaEditorRef.current?.compile();
      },
    }));

    return (
      <Tabs value={schemaSubTab} onValueChange={setSchemaSubTab} className="h-full flex flex-col">
        <TabsList className="grid w-full grid-cols-2 mb-4">
          <TabsTrigger value="schema">Schema</TabsTrigger>
          <TabsTrigger value="config">Config</TabsTrigger>
        </TabsList>

        <div className="flex-1 min-h-0">
          <TabsContent value="schema" className="m-0 h-full">
            <SchemaEditor
              ref={schemaEditorRef}
              value={schemaSource}
              onChange={onSchemaSourceChange}
              onCompileSuccess={onCompileSuccess}
              onCompileError={onCompileError}
              compileError={compileError}
              onCompileStart={onCompileStart}
              onCompileEnd={onCompileEnd}
            />
          </TabsContent>

          <TabsContent value="config" className="m-0 h-full">
            <ConfigEditor
              executionConfig={executionConfig}
              visualizationConfig={visualizationConfig}
              onExecutionConfigChange={onExecutionConfigChange}
              onVisualizationConfigChange={onVisualizationConfigChange}
            />
          </TabsContent>
        </div>
      </Tabs>
    );
  }
);

=== ./src/components/StickyActionBar.tsx ===
import { useState, useEffect, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Play, Pause, Code, Eye } from 'lucide-react';

interface StickyActionBarProps {
  action: 'compile' | 'execute' | 'run' | 'visualize' | 'play' | 'pause';
  onAction: () => void;
  disabled?: boolean;
  isLoading?: boolean;
}

/**
 * Floating action button that sits ABOVE the global bottom bar.
 * Respects --bottom-bar-h and iOS safe area insets.
 */
export function StickyActionBar({ action, onAction, disabled, isLoading }: StickyActionBarProps) {
  const isCompile = action === 'compile';
  const isRun = action === 'run';
  const isVisualize = action === 'visualize';
  const isPlay = action === 'play';
  const isPause = action === 'pause';
  const [showLoading, setShowLoading] = useState(false);

  useEffect(() => {
    let t: ReturnType<typeof setTimeout> | undefined;
    if (isLoading) t = setTimeout(() => setShowLoading(true), 300);
    else setShowLoading(false);
    return () => t && clearTimeout(t);
  }, [isLoading]);

  const bottomOffset = useMemo(
    () => `calc(var(--bottom-bar-h, 56px) + env(safe-area-inset-bottom, 0px) + 0.75rem)`,
    []
  );

  return (
    <div
      className="fixed left-1/2 -translate-x-1/2 z-50 animate-in slide-in-from-bottom-4 fade-in-0 duration-300"
      style={{ bottom: bottomOffset }}
    >
      <Button
        onClick={onAction}
        disabled={disabled}
        size="lg"
        className="h-14 px-8 shadow-2xl hover:shadow-primary/20 transition-transform hover:scale-105 focus-ring gap-3 text-base font-semibold"
      >
        {showLoading ? (
          <>
            <div className="h-5 w-5 animate-spin rounded-full border-2 border-primary-foreground border-t-transparent" />
            {isCompile ? 'Compiling…' : 'Executing…'}
          </>
        ) : (
          <>
            {isCompile && (<><Code className="h-5 w-5" />Compile</>)}
            {isRun && (<><Play className="h-5 w-5" />Run</>)}
            {isVisualize && (<><Eye className="h-5 w-5" />Visualize</>)}
            {isPlay && (<><Play className="h-5 w-5" />Play</>)}
            {isPause && (<><Pause className="h-5 w-5" />Pause</>)}
            <kbd className="ml-8 px-2 py-1 text-xs font-mono bg-primary-foreground/20 rounded">
              {isPlay || isPause ? '[Ctrl]+[Enter]' : '[Ctrl]+[Enter]'}
            </kbd>
          </>
        )}
      </Button>
    </div>
  );
}

=== ./src/components/ui/button.tsx ===
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

=== ./src/components/ui/card.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

=== ./src/components/ui/select.tsx ===
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-card px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring transition-all disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-70" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border border-border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-2 pl-8 pr-2 text-sm outline-none bg-popover focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent/50 transition-colors",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4 text-primary" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

=== ./src/components/ui/tabs.tsx ===
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground border border-border",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-transparent text-muted-foreground hover:text-foreground data-[state=active]:bg-card data-[state=active]:text-primary data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

=== ./src/components/ui/textarea.tsx ===
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

=== ./src/components/visualizers/GridVisualizer.tsx ===
import { renderAsciiGrid } from '@/rendering/ascii-grid';

interface GridVisualizerProps {
  name: string;
  value: any;
}

export function GridVisualizer({ name, value }: GridVisualizerProps) {
  if (!Array.isArray(value) || !Array.isArray(value[0])) {
    return (
      <div>
        <div className="font-medium mb-2">{name}:</div>
        <p className="text-destructive text-sm">
          Cannot render as grid: expected 2D array
        </p>
      </div>
    );
  }

  const ascii = renderAsciiGrid(value);

  return (
    <div>
      <div className="font-medium mb-2">{name}:</div>
      <pre role="group" className="font-mono text-sm bg-muted p-4 rounded overflow-x-auto">
        {ascii}
      </pre>
    </div>
  );
}

=== ./src/components/visualizers/TableVisualizer.tsx ===
import { renderAsciiTable } from '@/rendering/ascii-table';

interface TableVisualizerProps {
  name: string;
  value: any;
}

export function TableVisualizer({ name, value }: TableVisualizerProps) {
  if (!Array.isArray(value)) {
    return (
      <div>
        <div className="font-medium mb-2">{name}:</div>
        <p className="text-destructive text-sm">
          Cannot render as table: expected array, got {typeof value}
        </p>
      </div>
    );
  }

  const tableData = value.map((item, idx) => ({
    index: idx,
    value: item,
  }));

  const ascii = renderAsciiTable(tableData, ['index', 'value']);

  return (
    <div>
      <div className="font-medium mb-2">{name}:</div>
      <pre role="group" className="font-mono text-sm bg-muted p-4 rounded overflow-x-auto">
        {ascii}
      </pre>
    </div>
  );
}

=== ./src/components/VisualizeTab.tsx ===
import { useEffect, useRef, forwardRef, useImperativeHandle, useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { OutputView } from '@/components/OutputView';
import { VisualizationController } from '@/visualization/controller';
import { VisualizationEngine } from '@/visualization/engine';
import { windowScheduler } from '@/visualization/scheduler';
import { loadArtifactModule } from '@/execution/artifact-runner';
import type { CompileResponse } from '@/api/compile';
import type { Example, VisualizationConfig, ExecutionConfig } from '@/types';

interface VisualizeTabProps {
  compiledResult: CompileResponse;
  example?: Example;
  visualizationConfig?: VisualizationConfig;
  executionConfig?: ExecutionConfig;
}

export interface VisualizeTabRef {
  togglePlay: () => void;
  isPlaying: boolean;
  step: () => void;
}

export const VisualizeTab = forwardRef<VisualizeTabRef, VisualizeTabProps>(function VisualizeTab(
  { compiledResult, example, visualizationConfig, executionConfig },
  ref
) {
  const controllerRef = useRef<VisualizationController | null>(null);
  const [outputs, setOutputs] = useState<Record<string, any> | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);

  // build controller once
  if (controllerRef.current == null) {
    controllerRef.current = new VisualizationController(windowScheduler);
    controllerRef.current.onUpdate = (snap) => setOutputs(snap.outputs);
    controllerRef.current.onError = (msg) => setError(msg);
  }

  // init engine when artifact_url or example changes
  useEffect(() => {
    const url = compiledResult.artifact_url;
    if (!url) {
      setError('No executable artifact available. Recompile to get artifact_url.');
      return;
    }
    if (!compiledResult.output_schema) {
      setError('Missing output_schema from compile result.');
      return;
    }

    let mounted = true;

    (async () => {
      try {
        const mod = await loadArtifactModule(url);
        if (!mounted) return;

        const engine = new VisualizationEngine({
          mod,
          outputSchema: compiledResult.output_schema,
          execConfig: executionConfig,
          initialInput: example?.base_input,
        });

        await controllerRef.current!.init({
          engine,
          baseInput: example?.base_input,
        });

        setOutputs(null);
        setError(null);
        setIsPlaying(false);
      } catch (e) {
        if (!mounted) return;
        setError(e instanceof Error ? e.message : 'Failed to load artifact');
      }
    })();

    return () => {
      mounted = false;
      controllerRef.current?.pause();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [compiledResult.artifact_url, example?.id]);

  const step = () => controllerRef.current?.step();
  const togglePlay = () => {
    const speed = Math.max(50, executionConfig?.continuous?.playback_speed ?? 250);
    if (controllerRef.current?.isPlaying) controllerRef.current.pause();
    else controllerRef.current?.play(speed);
    setIsPlaying(controllerRef.current?.isPlaying ?? false);
  };

  useImperativeHandle(ref, () => ({
    togglePlay,
    isPlaying,
    step,
  }), [isPlaying]);

  return (
    <div className="h-full min-h-0 p-6">
      <div className="h-full">
        <Card className="shadow-lg border-2 h-full max-w-4xl mx-auto">
          <CardContent className="pt-6 h-full flex flex-col">
            <div className="flex items-center justify-between mb-4 shrink-0">
              <div className="text-sm text-muted-foreground">
                {isPlaying ? 'Playing' : 'Paused'}
              </div>
            </div>

            {error ? (
              <div className="text-destructive font-mono text-sm">{error}</div>
            ) : outputs ? (
              <div className="flex-1 min-h-0">
                <OutputView
                  results={outputs}
                  outputSchema={compiledResult.output_schema}
                  example={example}
                  visualizationConfig={visualizationConfig}
                />
              </div>
            ) : (
              <div className="flex-1 min-h-0 grid place-items-center text-muted-foreground">
                Press Play to visualize. Use ⌘/Ctrl+Enter to toggle.
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
});

=== ./src/design/README.md ===
# Design System

Minimal, modular styling architecture for Kumi Play.

## Architecture

- **Single source of truth**: `tailwind.config.js` for spacing tokens
- **No bloat**: Use Tailwind utilities directly, CVA for component variants
- **Keyboard-first**: `useKeyboard` hook for shortcuts

## Spacing Scale

```
xs:  0.5rem (8px)
sm:  0.75rem (12px)
md:  1rem (16px)
lg:  1.5rem (24px)
xl:  2rem (32px)
2xl: 3rem (48px)
3xl: 4rem (64px)
```

Usage: `gap-lg`, `px-md`, `py-xl`, etc.

## Components

- Use `focus-ring` utility class for consistent focus states
- Card components get `shadow-lg border-2` for depth
- Error states use `bg-destructive/10 border-destructive`

## Keyboard Shortcuts

- **Cmd/Ctrl + 1/2/3**: Switch between tabs (Schema/Compiled/Execute)
- **Cmd/Ctrl + S**: Compile schema

Add more via `useKeyboard` hook:
```tsx
useKeyboard({
  'meta+s': handleSave,
  'ctrl+k': openCommandPalette,
}, [deps]);
```

=== ./src/design/tokens.ts ===
export const spacing = {
  xs: '0.5rem',    // 8px
  sm: '0.75rem',   // 12px
  md: '1rem',      // 16px
  lg: '1.5rem',    // 24px
  xl: '2rem',      // 32px
  '2xl': '3rem',   // 48px
  '3xl': '4rem',   // 64px
} as const;

export const typography = {
  xs: '0.75rem',   // 12px
  sm: '0.875rem',  // 14px
  base: '1rem',    // 16px
  lg: '1.125rem',  // 18px
  xl: '1.25rem',   // 20px
  '2xl': '1.5rem', // 24px
  '3xl': '1.875rem', // 30px
} as const;

export const animation = {
  fast: '150ms',
  base: '250ms',
  slow: '350ms',
} as const;

=== ./src/examples/arithmetic.ts ===
import type { Example } from '@/types';

export const arithmetic: Example = {
  id: 'arithmetic',
  title: 'Basic Arithmetic',
  mode: 'notebook',
  schema_src: `schema do
  input do
    integer :x
    integer :y
  end

  value :sum, input.x + input.y
  value :product, input.x * input.y
  value :difference, input.x - input.y
end`,
  base_input: { x: 10, y: 5 },
};

=== ./src/examples/array-operations.ts ===
import type { Example } from '@/types';

export const arrayOperations: Example = {
  id: 'array-operations',
  title: 'Array Operations',
  mode: 'notebook',
  schema_src: `schema do
  input do
    array :items do
      hash :item do
        float :price
        integer :quantity
        string :category
      end
    end
    float :tax_rate
  end

  value :subtotals, input.items.item.price * input.items.item.quantity
  value :discounted_price, input.items.item.price * 0.9
  value :is_valid_quantity, input.items.item.quantity > 0
end`,
  base_input: {
    items: [
      { price: 150.0, quantity: 2, category: 'electronics' },
      { price: 75.0, quantity: 1, category: 'books' },
      { price: 200.0, quantity: 3, category: 'electronics' },
    ],
    tax_rate: 0.08,
  },
  visualizations: {
    subtotals: 'table',
    expensive_items: 'table',
    electronics: 'table',
    discounted_price: 'table',
    is_valid_quantity: 'table',
  },
};

=== ./src/examples/game-of-life.ts ===
import type { Example } from '@/types';

export const gameOfLife: Example = {
  id: 'game-of-life',
  title: "Conway's Game of Life",
  mode: 'notebook',
  schema_src: `schema do
  input do
    array :rows do
      array :col do
        integer :alive # 0 or 1
      end
    end
  end

  let :a, input.rows.col.alive

  # axis_offset: 0 = x, 1 = y
  let :n,  shift(a, -1, axis_offset: 1)
  let :s,  shift(a,  1, axis_offset: 1)
  let :w,  shift(a, -1)
  let :e,  shift(a,  1)
  let :nw, shift(n, -1)
  let :ne, shift(n,  1)
  let :sw, shift(s, -1)
  let :se, shift(s,  1)

  let :neighbors, fn(:sum, [n, s, w, e, nw, ne, sw, se])

  # Conway rules
  let :alive, a > 0
  let :n3_alive, neighbors == 3
  let :n2_alive, neighbors == 2
  let :keep_alive, n2_alive & alive

  let :next_alive, n3_alive | keep_alive

  value :next_state, select(next_alive, 1, 0)
end`,
  base_input: {
    rows: [
      [0, 0, 0, 0, 0],
      [0, 0, 1, 0, 0],
      [0, 0, 1, 0, 0],
      [0, 0, 1, 0, 0],
      [0, 0, 0, 0, 0],
    ],
  },
  visualization_config: { outputs: { next_state: { type: 'grid' } } },
  execution_config: {
    type: 'continuous',
    continuous: {
      feedback_mappings: [{ from_output: 'next_state', to_input: 'rows' }],
      playback_speed: 250,
    },
  },
};

=== ./src/examples/grid-shift.ts ===
import type { Example } from '@/types';

export const gridShift: Example = {
  id: 'grid-shift',
  title: '2D Grid Shift',
  mode: 'notebook',
  schema_src: `schema do
  input do
    array :rows do
      array :col do
        integer :v
      end
    end
  end

  value :shift_cols_right_zero,  shift(input.rows.col.v,  1)
  value :shift_cols_right_wrap,  shift(input.rows.col.v,  1, policy: :wrap)
  value :shift_cols_left_zero,   shift(input.rows.col.v, -1)
  value :shift_cols_left_wrap,   shift(input.rows.col.v, -1, policy: :wrap)

  value :shift_rows_down_zero,   shift(input.rows.col.v,  1, axis_offset: 1)
  value :shift_rows_down_wrap,   shift(input.rows.col.v,  1, axis_offset: 1, policy: :wrap)
  value :shift_rows_up_zero,     shift(input.rows.col.v, -1, axis_offset: 1)
  value :shift_rows_up_wrap,     shift(input.rows.col.v, -1, axis_offset: 1, policy: :wrap)
end`,
  base_input: {
    rows: [
      [100, 100, 100],
      [100, 255, 100],
      [100, 100, 100],
    ],
  },
  // visualizations: {
  //   shift_cols_right_zero: 'grid',
  //   shift_cols_right_wrap: 'grid',
  //   shift_cols_left_zero: 'grid',
  //   shift_cols_left_wrap: 'grid',
  //   shift_rows_down_zero: 'grid',
  //   shift_rows_down_wrap: 'grid',
  //   shift_rows_up_zero: 'grid',
  //   shift_rows_up_wrap: 'grid',
  // },
};

=== ./src/examples/index.ts ===
import type { Example } from '@/types';
import { arithmetic } from './arithmetic';
import { shoppingCart } from './shopping-cart';
import { arrayOperations } from './array-operations';
import { nestedHash } from './nested-hash';
import { tupleFunctions } from './tuple-functions';
import { gridShift } from './grid-shift';
import { gameOfLife } from './game-of-life';

export const examples: Example[] = [
  gameOfLife,
  arithmetic,
  shoppingCart,
  arrayOperations,
  nestedHash,
  tupleFunctions,
  gridShift,
];

export function getExample(id: string): Example | undefined {
  return examples.find((ex) => ex.id === id);
}

export function getDefaultExample(): Example {
  return examples[0];
}

=== ./src/examples/nested-hash.ts ===
import type { Example } from '@/types';

export const nestedHash: Example = {
  id: 'nested-hash',
  title: 'Nested Hash Access',
  mode: 'notebook',
  schema_src: `schema do
  input do
    hash :x do
      hash :y do
        integer :z
      end
    end
  end

  value :double, input.x.y.z * 2
end`,
  base_input: {
    x: {
      y: {
        z: 10,
      },
    },
  },
};

=== ./src/examples/shopping-cart.ts ===
import type { Example } from '@/types';

export const shoppingCart: Example = {
  id: 'shopping-cart',
  title: 'Shopping Cart',
  mode: 'notebook',
  schema_src: `schema do
  input do
    integer :price
    integer :quantity
    float :tax_rate
  end

  value :subtotal, input.price * input.quantity
  value :tax, subtotal * input.tax_rate
  value :total, subtotal + tax
end`,
  base_input: { price: 25, quantity: 3, tax_rate: 0.08 },
};

=== ./src/examples/tuple-functions.ts ===
import type { Example } from '@/types';

export const tupleFunctions: Example = {
  id: 'tuple-functions',
  title: 'Tuple Functions',
  mode: 'notebook',
  schema_src: `schema do
  input do
    integer :x
  end

  value :tuple, [1, 2, 3, input.x]
  value :max_1, fn(:max, tuple)
  value :max_2, fn(:max, [1, 2, 3, input.x, 1000])
  value :min_1, fn(:min, tuple)
  value :min_2, fn(:min, [1, 2, 3, input.x, -100])
end`,
  base_input: { x: 100 },
};

=== ./src/execution/artifact-runner.ts ===
// Artifact runner: loads compiled JS by URL and runs outputs.
import type { OutputField } from '@/types';

function toBase64(s: string){
  // btoa in browser, Buffer in Node/Vitest
  // @ts-ignore
  return typeof btoa === 'function' ? btoa(s) : Buffer.from(s,'utf8').toString('base64');
}

const moduleCache = new Map<string, Promise<any>>();

export async function loadArtifactModule(url: string){
  if (!url) throw new Error('artifact_url is empty');
  if (moduleCache.has(url)) return moduleCache.get(url)!;

  const p = (async () => {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status}: ${r.statusText}`);
    const js = await r.text();
    const mod = await import(/* @vite-ignore */ `data:text/javascript;base64,${toBase64(js)}`);
    return mod;
  })();

  moduleCache.set(url, p);
  return p;
}

export function clearArtifactCache(url?: string){
  if (url) moduleCache.delete(url);
  else moduleCache.clear();
}

export function executeOutput(mod: any, name: string, input: Record<string,any>){
  const fn = mod[`_${name}`];
  if (typeof fn !== 'function') throw new Error(`Output '${name}' not found in compiled module`);
  try { return fn(input); } catch (e) { throw new Error(`Execution failed for '${name}': ${(e as Error).message}`); }
}

export function runAllOutputs(mod: any, input: Record<string,any>, schema: Record<string,OutputField>){
  const out: Record<string,any> = {};
  for (const name of Object.keys(schema)) out[name] = executeOutput(mod, name, input);
  return out;
}

export async function runAllOutputsFromUrl(url: string, input: Record<string,any>, schema: Record<string,OutputField>){
  const mod = await loadArtifactModule(url);
  return runAllOutputs(mod, input, schema);
}

=== ./src/execution/continuous-execution.ts ===
import type { OutputField, ExecutionConfig } from '@/types';
import { runAllOutputsFromUrl } from './artifact-runner';
import { applyFeedbackMappings } from './feedback-loop';

export async function executeSingleIteration(
  artifactUrl: string,
  input: Record<string, any>,
  outputSchema: Record<string, OutputField>
): Promise<Record<string, any>> {
  return runAllOutputsFromUrl(artifactUrl, input, outputSchema);
}

export type IterationStep = {
  input: Record<string, any>;
  outputs: Record<string, any>;
};

export async function executeIterationLoop(
  artifactUrl: string,
  outputSchema: Record<string, OutputField>,
  config: ExecutionConfig,
  initialInput: Record<string, any>,
  maxIterations: number
): Promise<IterationStep[]> {
  const history: IterationStep[] = [];
  let currentInput = initialInput;

  for (let i = 0; i < maxIterations; i++) {
    const outputs = await executeSingleIteration(artifactUrl, currentInput, outputSchema);

    history.push({
      input: currentInput,
      outputs
    });

    currentInput = applyFeedbackMappings(config, outputs, currentInput);
  }

  return history;
}

=== ./src/execution/eval-module.ts ===
// Transitional shim. Prefer importing from './artifact-runner'.
export {
  loadArtifactModule as evalCompiledModuleFromUrl,
  runAllOutputsFromUrl as executeAllOutputsFromUrl,
  runAllOutputs as executeAllOutputs,
  executeOutput,
} from './artifact-runner';

=== ./src/execution/feedback-loop.ts ===
import type { ExecutionConfig } from '@/types';

export function applyFeedbackMappings(
  config: ExecutionConfig,
  outputs: Record<string, any>,
  currentInput: Record<string, any>
): Record<string, any> {
  if (config.type !== 'continuous' || !config.continuous?.feedback_mappings) {
    return currentInput;
  }

  const newInput = { ...currentInput };

  for (const mapping of config.continuous.feedback_mappings) {
    const outputValue = outputs[mapping.from_output];
    if (outputValue !== undefined) {
      newInput[mapping.to_input] = outputValue;
    }
  }

  return newInput;
}

=== ./src/hooks/useExampleState.ts ===
import { useState, useEffect, useRef } from 'react';
import type { Example, ExecutionConfig, VisualizationConfig } from '@/types';
import type { CompileResponse } from '@/api/compile';

interface ExampleState {
  schemaSource: string;
  compiledResult: CompileResponse | null;
  executionConfig: ExecutionConfig;
  visualizationConfig: VisualizationConfig;
}

export function useExampleState(example: Example) {
  const stateCache = useRef<Record<string, ExampleState>>({});
  const currentExampleId = useRef<string>(example.id);

  const getInitialState = (ex: Example): ExampleState => {
    if (stateCache.current[ex.id]) {
      return stateCache.current[ex.id];
    }

    return {
      schemaSource: ex.schema_src,
      compiledResult: null,
      executionConfig: ex.execution_config || { type: 'single' },
      visualizationConfig: ex.visualization_config || { outputs: {} },
    };
  };

  const [state, setState] = useState<ExampleState>(() => getInitialState(example));

  useEffect(() => {
    if (currentExampleId.current !== example.id) {
      stateCache.current[currentExampleId.current] = state;
      currentExampleId.current = example.id;
      setState(getInitialState(example));
    }
  }, [example.id]);

  useEffect(() => {
    stateCache.current[currentExampleId.current] = state;
  }, [state]);

  return {
    schemaSource: state.schemaSource,
    setSchemaSource: (schemaSource: string) => setState(s => ({ ...s, schemaSource })),
    compiledResult: state.compiledResult,
    setCompiledResult: (compiledResult: CompileResponse | null) => setState(s => ({ ...s, compiledResult })),
    executionConfig: state.executionConfig,
    setExecutionConfig: (executionConfig: ExecutionConfig) => setState(s => ({ ...s, executionConfig })),
    visualizationConfig: state.visualizationConfig,
    setVisualizationConfig: (visualizationConfig: VisualizationConfig) => setState(s => ({ ...s, visualizationConfig })),
  };
}

=== ./src/hooks/useKeyboard.ts ===
import { useEffect, useRef } from 'react';

type KeyHandler = (event: KeyboardEvent) => void;
type KeyMap = Record<string, KeyHandler>;

const isEditableElement = (element: Element | null): boolean => {
  if (!element) return false;
  const tag = element.tagName?.toLowerCase?.() || '';
  if (tag === 'input' || tag === 'textarea') return !(element as HTMLInputElement).readOnly;
  if ((element as HTMLElement).isContentEditable) return true;
  if (element.closest('.monaco-editor')) return true;
  return false;
};

const shouldIgnoreShortcut = (key: string, target: Element | null): boolean => {
  const inEditor = isEditableElement(target);
  if (!inEditor) return false;

  const allowedInEditor = [
    'meta+s', 'ctrl+s',
    'meta+enter', 'ctrl+enter',
    'escape', 'esc',
    '?',
  ];
  return !allowedInEditor.includes(key);
};

export function useKeyboard(keyMap: KeyMap, deps: unknown[] = []) {
  const throttleRef = useRef(0);

  useEffect(() => {
    const handler = (event: KeyboardEvent) => {
      const key = [
        event.ctrlKey && 'ctrl',
        event.metaKey && 'meta',
        event.shiftKey && 'shift',
        event.altKey && 'alt',
        event.key.toLowerCase(),
      ].filter(Boolean).join('+');

      if (shouldIgnoreShortcut(key, event.target as Element)) return;

      const now = performance.now();
      if (now - throttleRef.current < 60) return;

      const action = keyMap[key];
      if (!action) return;

      throttleRef.current = now;

      // If focus is on a tab trigger, blur it so shortcuts still work.
      const targetEl = event.target as Element | null;
      const tabEl = targetEl?.closest?.('[role="tab"]') as HTMLElement | null;
      if (tabEl) tabEl.blur();

      event.preventDefault();
      event.stopPropagation();
      // @ts-ignore
      if (typeof event.stopImmediatePropagation === 'function') event.stopImmediatePropagation();

      action(event);
    };

    // Capture phase to beat Radix key handlers and prevent flicker
    window.addEventListener('keydown', handler, { capture: true });
    return () => window.removeEventListener('keydown', handler, { capture: true } as any);
  }, deps);
}

=== ./src/hooks/useVisualization.ts ===
import { useEffect, useMemo, useSyncExternalStore } from 'react';
import { VisualizationController } from '@/visualization/controller';
import { WindowScheduler } from '@/visualization/scheduler';
import type { ExecutionConfig, OutputField } from '@/types';

export function useVisualization(opts: {
  artifactUrl?: string;
  initialInput?: Record<string, any>;
  outputSchema: Record<string, OutputField>;
  execConfig?: ExecutionConfig;
}) {
  const ctrl = useMemo(
    () => new VisualizationController(new WindowScheduler()),
    []
  );

  const subscribe = (cb: () => void) => ctrl.onChange(cb);
  const getSnapshot = () => ({
    isPlaying: ctrl.isPlaying,
    stepCount: ctrl.stepCount,
    outputs: ctrl.outputs,
    error: ctrl.error,
  });
  const snap = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);

  useEffect(() => {
    ctrl.init({
      artifactUrl: opts.artifactUrl || '',
      initialInput: opts.initialInput || {},
      outputSchema: opts.outputSchema,
      execConfig: opts.execConfig,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [opts.artifactUrl]);

  return {
    ...snap,
    play: () => ctrl.play(opts.execConfig),
    pause: () => ctrl.pause(),
    toggle: () => ctrl.toggle(opts.execConfig),
    step: () => ctrl.step(),
    setInput: (v: Record<string, any>) => ctrl.setInput(v),
  };
}

=== ./src/index.css ===

@plugin "tailwindcss-animate";

/* @import "tw-animate-css"; */

@tailwind base;
@tailwind components;
@tailwind utilities;

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --spacing-xs: 0.5rem;
  --spacing-sm: 0.75rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --spacing-2xl: 3rem;
  --spacing-3xl: 4rem;
  --radius: 0.375rem;

  /* Terminal-inspired dark theme: deep space blues with cyan/green accents */
  --background: oklch(0.12 0.02 240);
  --foreground: oklch(0.92 0.01 180);
  --card: oklch(0.15 0.02 240);
  --card-foreground: oklch(0.92 0.01 180);
  --popover: oklch(0.15 0.02 240);
  --popover-foreground: oklch(0.92 0.01 180);
  --primary: oklch(0.70 0.15 180);
  --primary-foreground: oklch(0.12 0.02 240);
  --secondary: oklch(0.20 0.02 240);
  --secondary-foreground: oklch(0.85 0.08 180);
  --muted: oklch(0.18 0.02 240);
  --muted-foreground: oklch(0.55 0.05 180);
  --accent: oklch(0.22 0.03 240);
  --accent-foreground: oklch(0.75 0.12 160);
  --destructive: oklch(0.60 0.20 30);
  --border: oklch(0.25 0.03 240);
  --input: oklch(0.18 0.02 240);
  --ring: oklch(0.70 0.15 180);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    border-color: var(--border);
    outline-color: color-mix(in oklab, var(--ring) 50%, transparent);
    font-family: 'Berkeley Mono', 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;
  }
  body {
    background-color: var(--background);
    color: var(--foreground);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-size: 14px;
    line-height: 1.6;
  }
  h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.3;
    letter-spacing: -0.01em;
  }
  code, pre {
    font-family: inherit;
  }
}

:root { --bottom-bar-h: 56px; }

@layer utilities {
  .focus-ring {
    outline: none;
    transition: box-shadow 150ms;
  }
  .focus-ring:focus-visible {
    outline: none;
    box-shadow:
      0 0 0 2px var(--ring),
      0 0 0 4px var(--background);
  }
  .pb-bottom-bar { padding-bottom: var(--bottom-bar-h) }
  .h-under-bar { height: calc(100vh - var(--bottom-bar-h)) }
}

/* Layout chrome sizes */
:root {
  --header-h: 64px;        /* adjust if your header is taller */
  --bottom-bar-h: 56px;    /* matches StickyActionBar/global bar */
}
/* Lock the page; only inner panes scroll */
html,body{height:100%;overflow:hidden}

@layer utilities {
  .h-under-chrome { height: calc(100vh - var(--header-h) - var(--bottom-bar-h)); }
  .pb-bottom-bar { padding-bottom: var(--bottom-bar-h) }
}

=== ./src/input-gen/random-fields.ts ===
import type { SimulationConfig } from '../types';
import { boxMullerRandom, uniformRandom } from './rng';

export function generateRandomFields(
  fields: SimulationConfig['random_fields']
): Record<string, number> {
  const result: Record<string, number> = {};

  for (const [key, config] of Object.entries(fields)) {
    if (config.distribution === 'normal') {
      result[key] = boxMullerRandom(config.mean, config.std);
    } else if (config.distribution === 'uniform') {
      result[key] = uniformRandom(config.min, config.max);
    }
  }

  return result;
}

=== ./src/input-gen/rng.ts ===
export function boxMullerRandom(mean = 0, std = 1): number {
  const u1 = Math.random();
  const u2 = Math.random();
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return z0 * std + mean;
}

export function uniformRandom(min: number, max: number): number {
  return Math.random() * (max - min) + min;
}

export function seededRng(seed: number) {
  let state = seed >>> 0;

  return function random(): number {
    state ^= state << 13;
    state ^= state >>> 17;
    state ^= state << 5;
    return (state >>> 0) / 0x100000000;
  };
}

=== ./src/lib/utils.ts ===
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

=== ./src/main.tsx ===
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

=== ./src/rendering/ascii-grid.ts ===
export function renderAsciiGrid(
  grid: number[][],
  char0: string = '░',
  char1: string = '█'
): string {
  if (grid.length === 0) return '';

  return grid
    .map(row =>
      row
        .map(cell => {
          if (cell === 0) return char0;
          if (cell === 1) return char1;

          // Handle grayscale (0-255)
          const normalized = Math.max(0, Math.min(255, cell)) / 255;
          if (normalized < 0.25) return ' ';
          if (normalized < 0.5) return '░';
          if (normalized < 0.75) return '▒';
          return '█';
        })
        .join('')
    )
    .join('\n');
}

=== ./src/rendering/ascii-histogram.ts ===
export function renderAsciiHistogram(
  data: number[],
  numBins: number = 10,
  barWidth: number = 30
): string {
  if (data.length === 0) return '';

  const min = Math.min(...data);
  const max = Math.max(...data);
  const range = max - min;

  if (range === 0) {
    return `${min.toFixed(1)}-${max.toFixed(1)} │ █ 1`;
  }

  const binSize = range / numBins;
  const bins: number[] = Array(numBins).fill(0);

  for (const value of data) {
    const binIndex = Math.min(
      numBins - 1,
      Math.floor((value - min) / binSize)
    );
    bins[binIndex]++;
  }

  const maxCount = Math.max(...bins);
  const lines: string[] = [];

  for (let i = 0; i < numBins; i++) {
    const binStart = min + i * binSize;
    const binEnd = binStart + binSize;
    const count = bins[i];
    const barLength = Math.round((count / maxCount) * barWidth);
    const bar = '█'.repeat(barLength) + '░'.repeat(barWidth - barLength);

    const label = `${binStart.toFixed(1)}-${binEnd.toFixed(1)}`.padEnd(12);
    lines.push(`${label}│ ${bar} ${count}`);
  }

  return lines.join('\n');
}

=== ./src/rendering/ascii-table.ts ===
export function renderAsciiTable(
  data: Record<string, any>[],
  columns: string[]
): string {
  if (data.length === 0 || columns.length === 0) return '';

  const colWidths = columns.map(col => {
    const dataWidth = Math.max(
      ...data.map(row => String(row[col] ?? '').length)
    );
    return Math.max(col.length, dataWidth, 3);
  });

  const header = columns
    .map((col, i) => col.padEnd(colWidths[i]))
    .join(' │ ');

  const separator = colWidths
    .map(width => '─'.repeat(width))
    .join('─┼─');

  const rows = data.map(row =>
    columns
      .map((col, i) => {
        const value = row[col];
        const str =
          typeof value === 'number' ? value.toFixed(2) : String(value ?? '');
        return str.padEnd(colWidths[i]);
      })
      .join(' │ ')
  );

  return ['┌─' + separator + '─┐', '│ ' + header + ' │', '├─' + separator + '─┤', ...rows.map(r => '│ ' + r + ' │'), '└─' + separator + '─┘'].join(
    '\n'
  );
}

=== ./src/stats/calculate-stats.ts ===
import type { Statistics } from '../types';

export function calculateStats(data: number[]): Statistics {
  if (data.length === 0) {
    throw new Error('Cannot calculate statistics for empty data');
  }

  const sorted = [...data].sort((a, b) => a - b);
  const n = sorted.length;

  const mean = data.reduce((sum, x) => sum + x, 0) / n;

  const variance = data.reduce((sum, x) => sum + (x - mean) ** 2, 0) / n;
  const std = Math.sqrt(variance);

  const median = sorted[Math.floor(n / 2)];

  const min = sorted[0];
  const max = sorted[n - 1];

  const p95 = sorted[Math.floor(n * 0.95)];

  return { mean, median, std, min, max, p95 };
}

=== ./src/test/setup.ts ===
import '@testing-library/jest-dom';
=== ./src/types/index.ts ===
export type InputField =
  | { type: 'string' | 'integer' | 'float' | 'boolean' }
  | { type: 'array'; element: InputField }
  | { type: 'object'; fields: Record<string, InputField> };

export type OutputField = {
  // Kind removed. Outputs are not differentiated.
  type?: 'string' | 'integer' | 'float' | 'boolean';
  axes?: string[];
};

export type CompileResult = {
  // URL for executable JS artifact produced by the compiler.
  artifact_url?: string;

  // Optional display artifacts for UI.
  js_src: string;
  ruby_src: string;
  lir: string;

  schema_hash: string;
  input_form_schema: Record<string, InputField>;
  output_schema: Record<string, OutputField>;
};

export type ExampleMode = 'notebook' | 'canvas' | 'simulation';
export type VisualizationType = 'json' | 'table' | 'grid';

export type ExecutionConfig = {
  type: 'single' | 'continuous';
  continuous?: {
    feedback_mappings: Array<{
      from_output: string;
      to_input: string;
    }>;
    max_iterations?: number;
    auto_start?: boolean;
    playback_speed?: number;
  };
};

export type VisualizationConfig = {
  outputs: Record<string, {
    type: VisualizationType;
    grid?: {
      cell_render?: 'numeric' | 'boolean' | 'custom';
      cell_map?: Record<string, string>;
    };
  }>;
};

export type CanvasConfig = {
  render: 'grid2d';
  controls?: {
    speed?: { min: number; max: number; default: number };
    seed?: { default: number };
  };
};

export type SimulationConfig = {
  iterations: number;
  random_fields: Record<
    string,
    | { distribution: 'normal'; mean: number; std: number }
    | { distribution: 'uniform'; min: number; max: number }
  >;
  track_outputs: string[];
};

export type Example = {
  id: string;
  title: string;
  schema_src: string;
  mode: ExampleMode;
  base_input?: Record<string, any>;
  execution_config?: ExecutionConfig;
  visualization_config?: VisualizationConfig;
  canvas_config?: CanvasConfig;
  simulation_config?: SimulationConfig;
  visualizations?: Record<string, VisualizationType>;
};

export type Statistics = {
  mean: number;
  median: number;
  std: number;
  min: number;
  max: number;
  p95: number;
};

=== ./src/visualization/controller.ts ===
import type { IScheduler } from './scheduler';
import { VisualizationEngine, type EngineSnapshot } from './engine';

type UpdateFn = (snapshot: EngineSnapshot) => void;

export class VisualizationController {
  private engine: VisualizationEngine | null = null;
  private scheduler: IScheduler;
  private timerId: number | null = null;
  private playing = false;
  private speed = 250;

  onUpdate?: UpdateFn;
  onError?: (message: string) => void;

  constructor(scheduler: IScheduler) {
    this.scheduler = scheduler;
  }

  get isPlaying(): boolean {
    return this.playing;
  }
  // replace the entire class body or just these methods if you prefer

  async init(opts: { engine?: any; baseInput?: Record<string, any> }) {
    this.engine = opts.engine;
    if (!this.engine) {
      this.onError?.('Engine not initialized');
      return;
    }
    if (opts.baseInput) this.engine.setInput(opts.baseInput);
    const snap = this.engine.snapshot();
    this.onUpdate?.(snap);
    if (snap.error) this.onError?.(snap.error);
  }

  step() {
    if (!this.engine) {
      this.onError?.('Engine not initialized');
      return;
    }
    const snap = this.engine.step();
    this.onUpdate?.(snap);
    if (snap.error) this.onError?.(snap.error);
  }

  private loop = (): void => {
    if (!this.playing) return;
    this.step();
    if (this.playing) {
      this.timerId = this.scheduler.set(this.speed, this.loop);
    }
  };

  play(speedMs: number): void {
    if (this.playing) return;
    this.playing = true;
    this.speed = speedMs;
    this.timerId = this.scheduler.set(this.speed, this.loop);
  }

  pause(): void {
    this.playing = false;
    if (this.timerId != null) {
      this.scheduler.clear(this.timerId);
      this.timerId = null;
    }
  }

  destroy(): void {
    this.pause();
    this.engine = null;
    this.onUpdate = undefined;
    this.onError = undefined;
  }
}

=== ./src/visualization/engine.ts ===
import type { ExecutionConfig, OutputField } from '@/types';
import { runAllOutputs } from '@/execution/artifact-runner';
import { applyFeedbackMappings } from '@/execution/feedback-loop';

export type EngineSnapshot = {
  stepCount: number;
  input: Record<string, any>;
  outputs: Record<string, any> | null;
  error: string | null;
};

export interface ModuleLike {
  [k: string]: any; // expects compiled functions named _<output>
}

export class VisualizationEngine {
  private mod: ModuleLike;
  private schema: Record<string, OutputField>;
  private execCfg?: ExecutionConfig;

  private _stepCount = 0;
  private _input: Record<string, any>;
  private _outputs: Record<string, any> | null = null;
  private _error: string | null = null;

  constructor(opts: {
    mod: ModuleLike;
    outputSchema: Record<string, OutputField>;
    execConfig?: ExecutionConfig;
    initialInput?: Record<string, any>;
  }) {
    this.mod = opts.mod;
    this.schema = opts.outputSchema;
    this.execCfg = opts.execConfig;
    this._input = opts.initialInput ?? {};
  }

  snapshot(): EngineSnapshot {
    return {
      stepCount: this._stepCount,
      input: this._input,
      outputs: this._outputs,
      error: this._error,
    };
  }

  setInput(next: Record<string, any>) { this._input = next; }

  step(): EngineSnapshot {
    try {
      const outputs = runAllOutputs(this.mod, this._input, this.schema);
      this._outputs = outputs;
      this._error = null;
      this._stepCount += 1;

      if (this.execCfg?.type === 'continuous' && this.execCfg.continuous?.feedback_mappings?.length) {
        this._input = applyFeedbackMappings(this.execCfg, outputs, this._input);
      }
    } catch (e) {
      this._error = e instanceof Error ? e.message : 'Execution failed';
    }
    return this.snapshot();
  }
}

=== ./src/visualization/scheduler.ts ===
export interface IScheduler {
  set(ms: number, cb: () => void): number;
  clear(id: number | null): void;
}

export class WindowScheduler implements IScheduler {
  set(ms: number, cb: () => void): number {
    return window.setTimeout(cb, ms);
  }
  clear(id: number | null): void {
    if (id != null) window.clearTimeout(id);
  }
}

export const windowScheduler = new WindowScheduler();

